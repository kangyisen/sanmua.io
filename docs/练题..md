# 牛客练习

[A-袋鼠将军的密码_牛客练习赛140](https://ac.nowcoder.com/acm/contest/111355/A)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
   ll n,m;
    string s;
void sove(){
    cin>>n>>m;
        cin>>s;
    if(n>=m){
        for(ll i=0;i<m;i++)cout<<s[i];
        cout<<"\n";
    }
    else cout<<-1<<"\n";
}
int main(){
ll t;
    cin>>t;
    while(t--){
        sove();
    }
    return 0;
}
```

第一题很简单，还需要做高难度题锻炼思维

# 异或的性质

[P1469 找筷子 - 洛谷](https://www.luogu.com.cn/problem/P1469)

```cpp
#include<iostream>
int x,n,ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        cin>>a[i];
        ans^=a[i];
    }
     
    printf("%d\n",ans);
}
```

异或的性质

# 二分

[P2249 【深基13.例1】查找 - 洛谷](https://www.luogu.com.cn/problem/P2249)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll maxn=1e6+5;
  ll n,m,x;
	ll a[maxn];
int find(int x){
ll l=1,r=n;
ll ans=-1;
while(l<=r){
	ll mid=(l+r)/2;
	if(a[mid]==x){
	ans=mid;r=mid-1;}
	else if(a[mid]>x)r=mid-1;
	else l=mid+1;
}
return ans;
}
int main(){
	cin>>n>>m;
	for(ll i=1;i<=n;i++)cin>>a[i];
	while(m--){
	cin>>x;
	cout<<find(x)<<" ";	
	}
	return 0;
}
```

简单二分，但是还是要多写才能掌握

# 纯高精度模拟

[P2437 蜜蜂路线 - 洛谷](https://www.luogu.com.cn/problem/P2437)

```cpp
蜂蜜：
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int M=2e5+5;
int a[M],b[M],ans[M];
string add(string x,string y)
{
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(ans,0,sizeof(ans));
	int jw=0;
	reverse(x.begin(),x.end());
	reverse(y.begin(),y.end());
	for(int i=0;i<x.size();i++) a[i]=x[i]-'0';
	for(int j=0;j<y.size();j++) b[j]=y[j]-'0';
	int len=max(x.size(),y.size());
	for(int i=0;i<=len;i++)
	{
		ans[i]=a[i]+b[i]+jw;
		jw=ans[i]/10;
		ans[i]%=10;
	}
	while(ans[len]==0&&len!=0) len--;
	string k;
	for(int i=len;i>=0;i--) k+=ans[i]+'0';
	return k;
}
signed main()
{
	int m,n;cin>>m>>n;
	int l=n-m;
	string xa="1",ho="1";
	for(int i=2;i<=l;i++)
	{
		string sum=add(xa,ho);
		ho=xa;
		xa=sum;
	}
	cout<<xa;
}
```

# 睿抗2024省赛个人题解

## 1

```cpp
#include<iostream>
using namespace std;
int main()
{
    int N,W;
    int cnt1=0,cnt2=0;
    cin>>N>>W;
    for(int i=0;i<N;i++)
    {
        int p;cin>>p;
        if(p>=35)
        {
            if(W%7==4)
                cnt2++;
            else
                cnt1++;
        }
        W++;
    }
    cout<<cnt1<<" "<<cnt2<<endl;
    return 0;
}
```

直接模拟就行，很简单的一道题

## 2

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,a[21],p,k;
int get(int p){
    if(p==1)return 12;
    if(p==2)return 9;
    if(p==3)return 7;
    if(p==4)return 5;
    if(p==5)return 4;
    if(p==6||p==7)return 3;
    if(p>=8&&p<=10)return 2;
    if(p>=11&&p<=15)return 1;
    if(p>=16&&p<=20)return 0;
}
int main(){
    cin>>n;
    for(ll i=0;i<n;i++){
        for(ll j=1;j<=20;j++){
            cin>>p>>k;
            a[j]+=get(p)+k;
        }
    }
    for(ll i=1;i<=20;i++){
        cout<<i<<" "<<a[i]<<"\n";
    }
    return 0;
}
```

同样模拟，没有难度

## 3

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
char a[1005][10005];
ll b[1005][1005];
ll c[1005][1005];
ll dx[8]={-1,-1,-1,0,0,1,1,1};
ll dy[8]={-1,0,1,-1,1,-1,0,1};
ll n,m;
vector<pair<ll,ll>>ans;
int main(){
    cin>>n>>m;
    for(ll i=1;i<=n;i++){
        for(ll j=1;j<=m;j++){
            cin>>a[i][j];
        }
    }
        for(ll i=1;i<=n;i++){
        for(ll j=1;j<=m;j++){
if(a[i][j]=='c'){
    for(ll k=0;k<8;k++){
        ll x=i+dx[k];
        ll y=j+dy[k];
        if(x>0&&x<=n&&y>0&&y<=m){
            b[x][y]=1;
        }
    }
}
        }
        }
            for(ll i=1;i<=n;i++){
        for(ll j=1;j<=m;j++){
if(a[i][j]=='m'){
    for(ll k=0;k<8;k++){
        ll x=i+dx[k];
        ll y=j+dy[k];
        if(x>0&&x<=n&&y>0&&y<=m){
            c[x][y]=1;
        }
    }
}
        }
        }
                 for(ll i=1;i<=n;i++){
        for(ll j=1;j<=m;j++){
if(a[i][j]=='w'&& !c[i][j]){
    for(ll k=0;k<8;k++){
        ll x=i+dx[k];
        ll y=j+dy[k];
        if(x>0&&x<=n&&y>0&&y<=m){
          if(!b[x][y]&&a[x][y]=='.'){
          ans.push_back({x,y});
          }
        }
    }
}
        }
        }  
        if(ans.empty())cout<<"Too cold!"<<"\n";
      else for(auto it:ans)cout<<it.first<<" "<<it.second<<"\n";    
       return 0;
}
```

有点难度，但不多

## 4

懒得写，后面再写

## 5

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,ans;
const ll maxn=5005;
struct stu{
    ll a,b,c;
}d[maxn];
ll dp[maxn];
bool cmp(stu n,stu m){
    if(n.b!=m.b)return n.b<m.b;
    if(n.a!=m.a)return n.a<m.a;
    return n.c>m.c;
}
int main(){
    ll t;
    cin>>t;
    while(t--){
    cin>>n;
        ans=0;
        memset(dp,0,sizeof(dp));
        for(ll i=1;i<=n;i++){
cin>>d[i].a>>d[i].b>>d[i].c;}
            sort(d+1,d+1+n,cmp);
        for(ll i=1;i<=n;i++){
            for(ll j=d[i].b;j>=d[i].a;j--){
               dp[j]=max(dp[j],dp[j-d[i].a]+d[i].c); 
                ans=max(ans,dp[j]);
            }
        }
        cout<<ans<<"\n";
}
return 0;}
```

背包问题，读懂题意比较重要

# atcoder

[現在のコンテスト - AtCoder](https://atcoder.jp/contests/)



## a

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,f;
string a,b;
int main(){
	cin>>n;
	cin>>a;
	cin>>b;
	for(ll i=0;i<n;i++){
		if(a[i]==b[i]&&a[i]=='o'&&b[i]=='o'){
			f=1;
			cout<<"Yes"<<"\n";
			break;
		}
	}
	if(!f)cout<<"No"<<"\n";
	return 0;
}
```

最简单的题，也只会这一个

## b

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,a[105],ans;
int main(){
cin>>n;
for(ll i=0;i<n;i++)cin>>a[i];
sort(a,a+n);
for(ll i=0;i<n;i++){
	ll b=n-i;
	if(a[i]>=b){
	ans=b;
	break;
	}
}
cout<<ans<<"\n";
	return 0;
}
```

没有输出0一直wa气死了

## c

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,l,x,b,ans;
map<ll,ll>mp;
int main(){
	mp[1]++;
	cin>>n>>l;
	n--;
	while(n--){
		cin>>x;
		b+=x;
		b=b%l;
		mp[b+1]++;
	}
//	cout<<mp.size();
//	for(auto it:mp)cout<<it.first<<" "<<it.second;
double m=l*1.0/3;
ll h=(ll)m;
if(h!=m){
cout<<ans;
return 0;}
for(ll i=1;i<=l;i++){
	if(mp[i]&&mp[i+m]&&mp[i+m+m]){
		ans+=mp[i]*mp[i+m]*mp[i+m+m]; 
		mp[i]=0,mp[i+m]=0,mp[i+m+m]=0;
	}
}
cout<<ans<<"\n";
return 0;
}
```

很简单的题不要想复杂了

# 洛谷

[P3156 【深基15.例1】询问学号 - 洛谷](https://www.luogu.com.cn/problem/P3156)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
map<ll,ll>a;
int main(){
    ll n,m,x;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>x;
        a[i]=x;
    }
    while(m--){
        cin>>x;
        cout<<a[x]<<"\n";
    }
    return 0;
}
```

算水题吧，挺简单的，练练手感

[P3613 【深基15.例2】寄包柜 - 洛谷](https://www.luogu.com.cn/problem/P3613)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
    ll n,m,i,j,k,x;
map<ll,ll>a[100005];
int main(){
    cin>>n>>m;
    while(m--){
        cin>>x;
        if(x==1){
            cin>>i>>j>>k;
            a[i][j]=k;
        }
        if(x==2){
            cin>>i>>j;
            cout<<a[i][j]<<"\n";
    }
    }
    return 0;
}

```

二维map对STL，要足够熟悉

# 牛客



[(0条未读通知) 牛客竞赛_ACM/NOI/CSP/CCPC/ICPC算法编程高难度练习赛_牛客竞赛OJ](https://ac.nowcoder.com/acm/contest/111159)

## a

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main(){
    ll l,r;
    cin>>l>>r;
    if((l-r)%2)cout<<2<<"\n";
    else cout<<1<<"\n";
    return 0;
}
```

## b

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main(){
    ll n;
    cin>>n;
    vector<ll>a(n+1);
    for(ll i=1;i<=n;i++){
        cin>>a[i];
    }
    ll q;
    cin>>q;
    while(q--){
        ll l,r;
        cin>>l>>r;
  cout<<a[l]<<" ";
        for(ll i=l+1;i<=r;i++)cout<<(a[i]-a[i-1])<<" ";
        cout<<"\n";
    }
    return 0;
}
```

## c

```cpp
#include<bits/stdc++.h>
using LL = long long;
using namespace std;
int main()
{
    LL d,p;
    cin>>d>>p;
    LL maxc=p/gcd(d,p);
    int q;
    cin>>q;
    while(q--)
    {
        LL l,r;
        cin>>l>>r;
        if(p==1&&l==1&&r!=1)cout<<"2"<<endl;
        else cout<<min(r-l+1,maxc)<<endl;
    }
    return 0;
}

```



## d

```
#include <bits/stdc++.h>
using namespace std;
int main ()
{
    int q;
    cin >> q;
    int ans = 1;
    set<int> s;
    while (q -- )
    {
        int l, r;
        cin >> l >> r;
        if (s.lower_bound(l) == s.upper_bound(r))
        {
            for (int i = l; i <= r; i ++ )
            {
                s.insert(i);
            }
            ans = max(r-l+2, ans);
        }
        cout << ans << endl;
    }
}
```

很厉害的方法，我没想到，多学

# pta练习



[L1-032 Left-pad - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805100684361728&page=0)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
string s;
ll n;
char a;
int main(){
    cin>>n>>a;
    getchar();
    getline(cin,s);
    ll m=s.size();
   // cout<<m;
    if(m<=n){
        for(ll i=0;i<n-m;i++)cout<<a;
        cout<<s<<"\n";
    }
    else cout<<s.substr(m-n,m)<<"\n";
}
```

# cf

[Dashboard - Codeforces Round 1029 (Div. 3) - Codeforces](https://codeforces.com/contest/2117)

## a

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
void sove(){
	ll n,m,f=0;
	cin>>n>>m;
	vector<ll>a(n+1);
	for(ll i=0;i<n;i++)cin>>a[i];
	for(ll i=0;i<n;i++){
		if(a[i]==1){
			while(m--){
				a[i]=0;
				i++;
				if(i>n)break;
			//	cout<<i;
			}
			break;
		}
	}
	for(ll i=0;i<n;i++){
		if(a[i]==1){
		cout<<"NO"<<"\n";
		f=1;
		break;
	}
}
	if(!f)cout<<"YES"<<"\n";
}
int main(){
ll t;
cin>>t;
while(t--){
	sove();
}
return 0;
}
```

## b

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int sove(){
	ll n;
	cin>>n;
cout<<1<<" ";
for(ll i=n;i>2;i--)cout<<i<<" ";
cout<<2<<" ";
	cout<<"\n"; 
}
int main(){
	ll t;
	cin>>t;
	while(t--){
		sove();
	}
}
```

# 牛客

[(0条未读通知) 牛客竞赛_ACM/NOI/CSP/CCPC/ICPC算法编程高难度练习赛_牛客竞赛OJ](https://ac.nowcoder.com/acm/contest/112544)

## A

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
string s;
int main(){
    cin>>s;
    for(ll i=0;i<s.size()-1;i++){
        if(s[i]=='9'&&s[i+1]=='9'){
            cout<<"YES"<<"\n";
            return 0;
        }
    }
    cout<<"NO"<<"\n";
    return 0;
}
```

## B

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
void sove(){
    ll n;
    cin>>n;
    string s;
    cin>>s;
    sort(s.begin(),s.end());
printf("%d\n",s[n-1]);
}
int main(){
    ll t;
    cin>>t;
    while(t--){
        sove();
    }
    return 0;
}
```



## c

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
void sove(){
ll k;
    cin>>k;
    if(k==0)cout<<1<<"\n";
    else if(k%2==0){
        ll n =k/2;
        while(n--)cout<<8;
        cout<<"\n";
    }
    else {
        cout<<4;
        ll n=k/2;
        while(n--)cout<<8;
        cout<<"\n";
    }
}
int main(){
    ll t;
    cin>>t;
    while(t--){
        sove();
    }
    return 0;
}
```

## d

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
void sove(){
    ll x,p;
    cin>>x>>p;
    ll a=p%x;
    ll b=p/x;
if(a==0)cout<<2*b-1<<"\n";
    else cout<<2*(x-1)*b+2*a<<"\n";
}
int main(){
    ll t;
    cin>>t;
    while(t--)sove();
    return 0;
}
```

# 洛谷

[P2241 统计方形（数据加强版） - 洛谷](https://www.luogu.com.cn/problem/P2241)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,cnt1,cnt2;
int main(){
cin>>n>>m;
    for(ll i=0;i<=n;i++){
        for(ll j=0;j<=m;j++){
            cnt1+=i*j;
            cnt2+=min(i,j);
        }
    }
    cout<<cnt2<<" "<<cnt1-cnt2;
    return 0;
}
```

[P3131 [USACO16JAN\] Subsequences Summing to Sevens S - 洛谷](https://www.luogu.com.cn/problem/P3131)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN = 1e5+10;
int N,C[MAXN], PS[MAXN], R[MAXN];
int L[7];

signed main() {
    cin >> N;
    int ans = 0;
    for(int i = 1; i <= N; i++){
        cin >> C[i];
        PS[i] = PS[i-1] + C[i];
        int r = PS[i] % 7;
        if(r){
            if(L[r] == 0)
                L[r] = i;
            else
                ans = max(ans, i - L[r]);
        }
        else
            ans = max(ans, i - 0);
    }
    cout << ans;
    return 0;
}
```

[P8649 [蓝桥杯 2017 省 B\] k 倍区间 - 洛谷](https://www.luogu.com.cn/problem/P8649)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN = 1e5+10;
int N,K, C[MAXN], PS[MAXN];
map<int,int> R;
signed main() {
    cin >> N >> K;
    R[0] = 1;
    int ans = 0;
    for(int i = 1; i <= N; i++){
        cin >> C[i];
        PS[i] = PS[i-1] + C[i];
        R[PS[i]%K]++;
    }
    for(auto [r,cnt] : R)
        ans += (cnt-1)*cnt/2;
    cout << ans;
    return 0;
}
```

# 牛客

[牛客竞赛_ACM/NOI/CSP/CCPC/ICPC算法编程高难度练习赛_牛客竞赛OJ](https://ac.nowcoder.com/acm/contest/113313#question)

## a

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
void sove(){
ll a;
double b;
cin>>a;
b=150*log(a);
printf("%lf",b);
}
int main(){
    ll t;
    //cin>>t;
    t=1;
    while(t--)sove();
    return 0;
}
```



## b

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
void sove(){
    ll n,a=0,b=0,c=0,d=0;
    cin>>n;
a=n/5*2;
b=(n-5)/10+1;
c=n/20*3;
d=(n-c/3)*2;
cout<<a<<" "<<b<<" "<<c<<" "<<d<<"\n";
}
int main(){
    ll t;
    //cin>>t;
    t=1;
    while(t--)sove();
    
    return 0;
}
```

## c

```cpp
#include <iostream>
using namespace std;

long long maxXOR(long long n) {
    if (n == 1) return 1;
    long long m = 1;
    while (m <= n) {
        m <<= 1;
    }
    return m - 1;
}

int main() {
    long long n;
    cin >> n;
    cout << maxXOR(n) << endl;
    return 0;
}

```

# 洛谷

[P2032 扫描 - 洛谷](https://www.luogu.com.cn/problem/P2032)

**单调队列**

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<deque>
using namespace std;
deque<int> dq;
int n,k,a[2000001];
void into(int x)
{
	while(!dq.empty()&&a[x]>a[dq.back()]){
		dq.pop_back();
	}
	if(!dq.empty()&&x-dq.front()>=k){
		dq.pop_front();
	}
	dq.push_back(x);
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
    	
		cin>>a[i];
		into(i);
		if(i>=k)cout<<a[dq.front()]<<endl;
	}
	return 0;
}
```

[P5788 【模板】单调栈 - 洛谷](https://www.luogu.com.cn/problem/P5788)

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
stack<int>s;
int main()
{
	scanf("%d",&n);
	vector<int>a(n+1),f(n+1);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=n;i>=1;i--)
	{
		while(!s.empty()&&a[s.top()]<=a[i]) s.pop();
		f[i]=s.empty()?0:s.top();
		s.push(i);
	}
	for(int i=1;i<=n;i++) printf("%d ",f[i]);
	return 0;
}
```

# 睿抗

[购买考试券 - 2024 睿抗机器人开发者大赛CAIP-编程技能赛-本科组（国赛）](https://pintia.cn/market/item/1820039029121159168)

## a

```cpp
#include <bits/stdc++.h>
 using namespace std;
 int main()
 {
     string s;
     vector<string> res;
     while (getline(cin, s))
     {
         string t;
         for (int i = 0; i < s.size(); i++)
         {
             if ((s[i] >= '0' && s[i] <= '9') || (s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z'))
             {
                 t += s[i];
             }
             else
             {
                 if (t.size())   res.push_back(t);
                 t = "";
             }
         }
         if (t.size())   res.push_back(t);
     }
     
 //  for (auto x : res)  cout << x << "\n";
     int resscore = 0;
     for (auto x : res)
     {
         int daxie = 0, xiaoxie = 0, num = 0;
         for (int i = 0; i < x.size(); i++)
         {
             if (x[i] >= '0' && x[i] <= '9') num++;
             else if (x[i] >= 'a' && x[i] <= 'z')    xiaoxie++;
             else    daxie++;
         }
         if (daxie && xiaoxie && num)    resscore += 5;
         else if (num && (daxie || xiaoxie)) resscore += 3;
         else if (daxie && xiaoxie && !num)  resscore++;
     }
     cout << resscore << "\n";
     int reslen = 0;
     for (auto x : res)  reslen += x.size();
     cout << reslen << " " << res.size() << "\n";
     return 0;
 }
```

## b

```cpp
#include <bits/stdc++.h>
 using namespace std;
 using pii = pair<int, int>;
 int get_score(int x)
 {
     if (x == 1) return 25;
     else if (x == 2)    return 21;
     else if (x == 3)    return 18;
     else if (x == 4)    return 16;
     else
     {
         int res = 16;
         return res - (x - 4);
     }
 }
 int main()
 {
     int n;
     cin >> n;
     
     map<int, int> mp;
     for (int i = 1; i <= n; i++)
     {
         for (int j = 1; j <= 20; j++)
         {
             int c, p;
             cin >> c >> p;
             mp[c] += get_score(p);
         }
     }
     
     vector<pii> res;
     for (auto [x, y] : mp)
     {
         res.push_back({x, y});
     }
     
     sort(res.begin(), res.end(), [&](pii a, pii b) -> bool{
         if (a.second != b.second)   return a.second > b.second;
         return a.first < b.first;
     });
     
     for (auto x : res)  cout << x.first << " " << x.second << "\n";
     return 0;
 }
```

## c

```cpp
#include <bits/stdc++.h>
 using namespace std;
 int main(){
 int n;
     cin>>n;
     vector<int>a(n);
     for(int i=0;i<n;i++)cin>>a[i];
     if(n==3){
       cout<<a[0]<<a[1]<<a[2]<<"\n";  
           cout<<a[1]<<a[2]<<a[0]<<"\n";
           cout<<a[2]<<a[0]<<a[1];
     }
     if(n==4){
           cout<<a[0]<<a[1]<<a[2]<<a[3]<<"\n";  
           cout<<a[1]<<a[2]<<a[0]<<a[3]<<"\n";
          cout<<a[2]<<a[0]<<a[1]<<a[3]<<"\n"; 
         cout<<a[3]<<a[1]<<a[2]<<a[0]<<"\n";  
           cout<<a[1]<<a[2]<<a[3]<<a[0]<<"\n";
          cout<<a[2]<<a[3]<<a[1]<<a[0]<<"\n"; 
                cout<<a[0]<<a[3]<<a[2]<<a[1]<<"\n";  
           cout<<a[3]<<a[2]<<a[0]<<a[1]<<"\n";
                cout<<a[0]<<a[1]<<a[3]<<a[2]<<"\n";  
           cout<<a[1]<<a[3]<<a[0]<<a[2]<<"\n";
          cout<<a[3]<<a[0]<<a[1]<<a[2]<<"\n"; 
          cout<<a[2]<<a[0]<<a[3]<<a[1]; 
     }
   return 0;
 }
```

这个题打表给我打爽了，打着打着就笑了

## 洛谷

[P7072 [CSP-J2020\] 直播获奖 - 洛谷](https://www.luogu.com.cn/problem/P7072)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
ll t[610],n,w;
void sove(){
ll tmp;
cin>>n>>w;
for(ll i=1;i<=n;i++){
    cin>>tmp;
    t[tmp]++;
    ll sum=0;
for(ll j=600;j>=0;j--){
    sum+=t[j];
    ll ans=1;
    if(sum>= max(ans,i*w/100)){
        cout<<j<<" ";
        break;
    }
}
}
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    ll t;
   // cin>>t;
   t=1;
    while(t--)sove();
    
    return 0;
}
```

空间换时间，直接模拟即可

## atcoder

[Tasks - AtCoder Beginner Contest 417](https://atcoder.jp/contests/abc417/tasks)

## a

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;

void sove(){
string  s;
ll a,b,n;
cin>>n>>a>>b;
cin>>s;
for(ll i=a;i<n-b;i++){
    cout<<s[i];
}
cout<<"\n";
}
int main(){
    ll t;
  //  cin>>t;
  t=1;
    while(t--)sove();
    
    return 0;
}
    
```

## b

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;

void sove(){
ll n,m,x;
cin>>n>>m;
map<ll,ll>mp;
vector<ll>a(n+1),b(n+1);
for(ll i=0;i<n;i++){
    cin>>a[i];
    mp[a[i]]++;
}
for(ll i=0;i<m;i++){
cin>>x;
if(mp[x])mp[x]--;
}
for(auto r:mp){
    for(ll i=0;i<r.second;i++){
        cout<<r.first<<" ";
    }
}
cout<<"\n";
}
int main(){
    ll t;
  //  cin>>t;
  t=1;
    while(t--)sove();
    
    return 0;
}
```

## c

```cpp
#include <bits/stdc++.h> // 包含标准模板库中的所有头文件，这是一个非标准的做法，通常不推荐使用
using namespace std; // 使用标准命名空间，避免每次调用标准库时都需要加std::前缀
typedef long long ll; // 为long long类型定义别名ll，方便后续使用
const ll mod = 1e9 + 7; // 定义一个常量mod，值为1000000007，通常用于取模运算，防止整数溢出

// 定义一个函数sove，用于解决问题
void sove() {
    ll n, ans = 0; // 定义变量n用于存储输入的数据个数，ans用于存储最终的结果，初始化为0
    cin >> n; // 从标准输入读取n的值
    vector<ll> a(n + 1); // 定义一个长度为n+1的向量a，用于存储输入的数据，注意长度加1是为了方便后续处理
    for (ll i = 1; i <= n; i++) { // 使用循环读取n个数据，存储在向量a中，注意从索引1开始存储
        cin >> a[i]; // 读取一个数据并存储在向量a的对应位置
    }
    map<ll, ll> mp; // 定义一个map，用于存储某个值出现的次数
    for (ll r = 1; r <= n; r++) { // 使用循环遍历向量a中的每个元素
        ll k = r - a[r]; // 计算当前位置r与对应值a[r]的差，存储在变量k中
        if (mp[k]) { // 如果map中已经存在键为k的条目，说明之前已经遇到过r-a[r]这个差
            ans += mp[k]; // 将这个差出现的次数累加到ans中，因为每次遇到相同的差，就意味着找到了一个满足条件的数对
        }
        mp[a[r] + r]++; // 将当前值a[r]与位置r的和作为键，存储在map中，并增加其对应的计数
    }
    cout << ans << "\n"; // 输出最终的结果ans
}

int main() {
    ll t; // 定义变量t用于存储测试用例的数量
    //cin >> t; // 这行代码被注释掉了，原本用于读取测试用例的数量
    t = 1; // 将t硬编码为1，意味着只处理一个测试用例
    while (t--) sove(); // 当t大于0时，调用sove函数处理测试用例，每次循环t减1
    
    return 0; // 程序正常结束，返回0
}
```

## d

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 1e5+10, mod = 1e9+7;
int n,m,p[N],a[N],b[N];
void sove(){
        cin>>n;
    ll sum = 0;
    int ma = 0;
    for(int i=1;i<=n;i++) {
        cin>>p[i]>>a[i]>>b[i];
        sum += b[i];
        ma = max(a[i],ma);
    }
    ll V = ma + sum;
    ll q;
cin>>q;
    while(q--){
        ll x;
        cin>>x;
        if(x>=V) cout<<x-sum<<'\n';
        else{
            for(int i=1;i<=n;i++){
                if(x>p[i]) x = max(x-b[i],0ll);
                else x+=a[i];
            }
            cout<<x<<'\n';
        }
    }
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    ll t;
    //cin>>t;
    t=1;
    while(t--) sove();
    
    return 0;
}
```



# 洛谷

[P1029 [NOIP 2001 普及组\] 最大公约数和最小公倍数问题 - 洛谷](https://www.luogu.com.cn/problem/P1029)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
void sove(){
{
    int x, y;
    cin >> x >> y; 
    if (y % x > 0)
    {
    	cout << 0;
    	return ;
	}
    int num = y / x, cnt = 0;
    for (int i = 1; i <= num; ++i) 
    {
        if (num % i == 0 && num % (num / i) == 0)
        {
            if (__gcd(i, num / i) == 1) 
            {
                cnt += 1; 
            }
        }
        
    }
    cout << cnt; 
    return ;
}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
    ll t;
   // cin>>t;
   t=1;
    while(t--)sove();
    
    return 0;
}

```



# 睿抗

## 4



```cpp
#include<bits/stdc++.h> // 包含标准模板库中的所有头文件
using namespace std; // 使用标准命名空间

int T,n,m,ans1 = 1,ans2,max_num = 0; // 定义全局变量：T为测试用例数，n为节点数，m为边数，ans1和ans2用于存储最长和次长路径长度，max_num未使用
bool vis[15]; // 定义一个布尔数组，用于标记节点是否已访问，大小为15
vector <int> G[55]; // 定义一个邻接表数组，用于存储图，大小为55

// 定义深度优先搜索函数，用于查找从节点cur开始，经过节点start的最长路径长度
void dfs(int cur,int start,int cnt)
{
    for(auto t : G[cur]) // 遍历当前节点cur的所有邻接节点
    {
        if(vis[t]) // 如果节点t已被访问，则跳过
            continue;
        if(t == start) // 如果找到了起始节点start
        {
            if(ans1 < cnt) // 如果当前路径长度大于已知的最长路径长度
            {
                ans2 = ans1; // 更新次长路径长度为当前的最长路径长度
                ans1 = cnt; // 更新最长路径长度为当前路径长度
            }
            else if(ans1 != cnt && ans2 < cnt) // 如果当前路径长度大于次长路径长度且不等于最长路径长度
            {
                ans2 = cnt; // 更新次长路径长度为当前路径长度
            }
        }
        vis[t] = true; // 标记节点t为已访问
        dfs(t,start,cnt+1); // 递归调用dfs函数，继续搜索
        vis[t] = false; // 回溯，标记节点t为未访问
    }
}

int main(void)
{
    ios::sync_with_stdio(0); // 关闭C++标准库与C标准库的输入输出同步
    cin.tie(0); // 解除cin与cout的绑定
    cout.tie(0); // 解除cin与cout的绑定
    cin >> T; // 输入测试用例数
    while(T--) // 循环处理每个测试用例
    {
        ans1 = 1,ans2 = 0; // 初始化最长路径长度为1，次长路径长度为0
        cin >> n >> m; // 输入节点数和边数
        for(int i = 1 ; i <= n ; i++) // 初始化每个节点的邻接表
            G[i].clear();
        for(int i = 1 ; i <= m ; i++) // 输入每条边的两个节点
        {
            int x,y;
            cin >> x >> y;
            G[x].push_back(y); // 在邻接表中添加边
            G[y].push_back(x); // 在邻接表中添加反向边
        }
        for(int i = 1 ; i <= n ; i++) // 对每个节点执行深度优先搜索
        {
            dfs(i,i,1); // 从节点i开始搜索，起始节点也为i，路径长度为1
        }
        cout << ans1 << " " << ans2 << endl; // 输出最长路径长度和次长路径长度
    }
    return 0; // 程序结束
}
```

# 牛客

[B-小红的不动点构造_牛客周赛 Round 104](https://ac.nowcoder.com/acm/contest/114848/B)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
void sove(){
ll n,k;
cin>>n>>k;
if(n-1==k){
    cout<<-1;return ;
}
vector<ll>a(n+1);
for(ll i=1;i<=n;i++){
    a[i]=i;
}
for(ll i=k+1;i<n;i++){
    swap(a[i],a[i+1]);
}
for(ll i=1;i<=n;i++){
    cout<<a[i]<<" ";
}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
    ll t;
    //cin>>t;
    t=1;
    while(t--)sove();
    
    return 0;
}

```

# 洛谷

[P5908 猫猫和企鹅 - 洛谷](https://www.luogu.com.cn/problem/P5908)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,d,ans;
ll dis[100001];
vector<ll> g[100001];
void add(ll u,ll v){
    g[u].push_back(v);
    g[v].push_back(u);
}
void dfs(ll u,ll f){
if(dis[u]<=d)ans++;
for(ll t :g[u]){
    if(t==f)continue;
    dis[t]=dis[u]+1;
    dfs(t,u);
}
}
void sove(){
    cin>>n>>d;
    for(ll i=1;i<n;i++){
        ll u,v;
        cin>>u>>v;
        add(u,v);
    }
    dfs(1,0);
    cout<<ans-1<<endl;
}
int main(){
ll t;
t=1;
while(t--){
    sove();
}
return 0;
}
```

[P2842 纸币问题 1 - 洛谷](https://www.luogu.com.cn/problem/P2842)

```cpp
#include<bits/stdc++.h>                  // 引入所有标准库头文件
using namespace std;                      // 使用标准命名空间
typedef long long ll;                     // 定义ll为long long的简写
const ll mod = 1e9 + 7;                   // 定义常量mod为1e9+7
ll f[1000005], a[1000005];                // 定义两个长度为1000005的long long数组f和a

void sove(){                              // 定义求解函数
    ll n,w;                               // 定义n和w变量
    cin>>n>>w;                            // 输入n和w
    for(ll i=1;i<=n;i++){                 // 循环输入n个数
        cin>>a[i];                        // 输入第i个数到数组a
    }
    for(ll i=1;i<=w;i++){                 // 对1到w的每个数进行处理
        f[i]=mod;                         // 初始化f[i]为mod（无穷大）
        for(ll j=1;j<=n;j++){             // 遍历每个物品
            if(a[j]<=i){                  // 如果第j个物品可以放入容量为i的背包
                f[i]=min(f[i],f[i-a[j]]+1); // 状态转移，取最小值
            }
        }
    }
    cout<<f[w]<<"\n";                     // 输出容量为w时的最小物品数
}

int main(){                               // 主函数入口
    ios::sync_with_stdio(0);              // 关闭同步，提高cin/cout效率
    cin.tie(0),cout.tie(0);               // 解除cin和cout的绑定
    ll t;                                 // 定义t变量
//    cin>>t;                             // （注释）输入测试组数
    t=1;                                  // 只运行一次
    while(t--)sove();                     // 调用sove函数
    return 0;                             // 返回0，程序结束
}

```



# pta

[PTA | 程序设计类实验辅助教学平台](https://pintia.cn/market/tag/1447465711671738368)

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m,ans1 = 1,ans2,max_num = 0;
bool vis[15];
vector <int> G[55];
void dfs(int cur,int start,int cnt)
{
		for(auto t : G[cur])
		{
			if(vis[t])
			continue;
			if(t == start)
			{
				if(ans1 < cnt)
				{
					ans2 = ans1;
					ans1 = cnt;
				}
				else if(ans1 != cnt && ans2 < cnt)
				{
					ans2 = cnt;
				}
			}
			vis[t] = true;
			dfs(t,start,cnt+1);
			vis[t] = false;
		}
}
int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0); 
	cin >> T;
	while(T--)
	{
		ans1 = 1,ans2 = 0;
		cin >> n >> m;
		for(int i = 1 ; i <= n ; i++)
		G[i].clear();
		for(int i = 1 ; i <= m ; i++)
		{
			int x,y;
			cin >> x >> y;
			G[x].push_back(y);
			G[y].push_back(x);
		}
		for(int i = 1 ; i <= n ; i++)
		{
			dfs(i,i,1);
		}
		cout << ans1 << " " << ans2 << endl;
	}
		return 0;
 } 
```

[购买考试券 - 2025年睿抗机器人开发者大赛CAIP-编程技能赛（国赛）-本科组](https://pintia.cn/market/item/1956676539920936960)

## c



```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n=0;
    string a;
    cin >> a;
    char b = a[0];
    char d = a[1];
    stack<char> s;
    char c;
    while (cin >> c) {
        n++;
        if (!s.empty() && c == d&& s.top() == b) {
            s.pop();
        } else {
            s.push(c);
        }
    }
    vector<char> p;
    cout << (n-s.size())/2 <<" ";
  while(!s.empty()){
        p.push_back(s.top());
        s.pop();
    }
    reverse(p.begin(),p.end());
for(auto m:p)
    cout<<m;
    return 0;
}

```

# cf

[Dashboard - Codeforces Round 1047 (Div. 3) - Codeforces](http://link.zhihu.com/?target=https%3A//codeforces.com/contest/2137)

## a

**直接让x一直除以二即可**

```text
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
void sove(){
 ll k,x,ans;
 cin>>k>>x;
 ans=pow(2,k)*x;
 cout<<ans<<"\n";
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
    ll t;
    cin>>t;
    while(t--)sove();
    
    return 0;
}
```

## b

**n<2交换位置，n>2，输出的数等于n即可，下面题解写的很麻烦，可简化**

```text
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
void sove(){
ll n;
cin>>n;
if(n<=2){
    ll a,b;
    cin>>a>>b;
    cout<<b<<" "<<a<<"\n";
    return;
}
vector<ll>a(n),b(n);
b.clear();
for(ll i=0;i<n;i++){
    cin>>a[i];
    if(a[i]==n)b.push_back(n);
    else b.push_back(n-a[i]);
}
for(auto m:b)cout<<m<<" ";
cout<<"\n";
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
    ll t;
    cin>>t;
    while(t--)sove();
    
    return 0;
}
```

## c

**结论我猜的，就是偶数就加2，奇数加1，奇数除以原数，偶数除以剩余2的数**

```text
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
bool f(ll n){
    if(n%2==0)return 1;
     return 0;
}
void sove(){
ll a,b,ans=0;
cin>>a>>b;
if(f(b))ans=b/2*a+2;
else if(!f(b))ans=a*b+1;
 if(!f(ans))ans=-1;
cout<<ans<<"\n";
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
    ll t;
    cin>>t;
    while(t--)sove();
    
    return 0;
}
```

## d

**这个题有点考验思维，一步一步去推理之后就不是很难理解**

```text
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
void sove(){
ll n,sum=0;
cin>>n;
map<ll,ll>mp;
mp.clear();
vector<ll>a(n,0);
for(ll i=0;i<n;i++){
    cin>>a[i];
mp[a[i]]++;
}
for(ll i=1;i<=n;i++){
    if(mp[i]&&mp[i]%i!=0){
        cout<<-1<<"\n";
        return ;
    }
}
ll cnt=1,m=0;
vector<ll>p(n+1);
vector<ll>v(n+1,0);
for(auto x:a){
    if(p[x]%x==0){
        v[x]=cnt++;
}
cout<<v[x]<<" ";
p[x]++;
}
cout<<"\n";
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
    ll t;
    cin>>t;
    while(t--)sove();
    
    return 0;
}
```

https://atcoder.jp/contests/abc424

# atcoder

# a

个人

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
void sove(){
ll a,b,c;
cin>>a>>b>>c;
if(a==b||a==c||b==c)cout<<"Yes\n";
else cout<<"No\n";
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
    ll t;
    //cin>>t;
    t=1;
    while(t--)sove();
    
    return 0;
}

```

标答

三角形ABC是等腰三角形，当且仅当满足以下条件之一：
a等于b，
b等于c，或
c等于a。
这可以通过一个条件语句进行检查。例如，

以下是C++的示例代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(void){
    int a,b,c;
    cin>>a>>b>>c;
    if((a==b)|(b==c)|(c==a))cout<<"Yes"<<endl;
    else cout<<"No"<<endl;
    return 0;
}
```

# b

个人

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
void sove(){
ll n,m,k;
ll a[15][15];
map<ll,ll>mp;
vector<ll>v;
memset(a,0,sizeof(a));
cin>>n>>m>>k;
while(k--){
    ll c,d;
    cin>>c>>d;
if(!a[c][d])mp[c]++;
a[c][d]=1;
if(mp[c]==m)v.push_back(c);}
for(auto x:v)cout<<x<<" ";
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
    ll t;
   // cin>>t;
   t=1;
    while(t--)sove();
    return 0;
}

```

标答

考虑管理每个人解决了哪些问题。

- 具体来说，维护一个标志数组，表示每个人 *i* 是否解决了问题 *j*，其中 1≤*i*≤*N* 且 1≤*j*≤*M*。初始时，所有标志都设为 `False`。
  此外，对于每个人，维护一个标志，表示他们是否解决了所有问题。这些标志初始时也都设为 `False`。
  最后，准备一个列表（`vector`），按时间顺序存储解决了所有问题的人的编号，最终将打印这个列表。

  对于每个 *K* 个事件，重复以下操作：

  1. 将表示人 *a<sub>i</sub>* 是否解决了问题 *b<sub>i</sub>* 的标志设为 `True`。
  2. 检查每个人是否解决了所有问题。如果人 *i* 解决了所有问题，且表示该状态的标志为 `False`，则将人 *i* 添加到输出列表中，并将标志设为 `True`。
  3. 最后，打印列表中存储的人的编号，用空格分隔。

  上述过程的总计算复杂度为 *O*(*K**NM*)，因为每次事件后都会检查所有标志；然而，由于没有重复事件，*K*≤*NM*，因此计算复杂度为 *O*(*N*2*M*2)——在问题的约束下足够快。

  实际上，可以进行以下优化：

  - 在第 *i* 个事件中，只有 *A**i* 可能新成为解决了所有问题的人，因此只需检查 *A**i* 的标志。这将复杂度降低到 *O*(*K**M*)。
  - 由于没有重复事件，不需要管理每个人解决了哪些问题，只需管理每个人解决了多少问题。时间复杂度为 *O*(*K*)（空间复杂度为 *O*(*N*)）。

C++ 示例代码（朴素解法）：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(void){
    int n, m, k;
    int a, b, cnt;
    bool solved[10][10] = {};
    bool recorded[10] = {};
    vector<int> ans;
    cin >> n >> m >> k;
    for (int ievent = 0; ievent < k; ievent++) {
        cin >> a >> b;
        solved[a-1][b-1] = true;
        for (int i = 0; i < n; i++) {
            cnt = 0;
            for (int j = 0; j < m; j++) {
                if (solved[i][j]) cnt++;
            }
            if ((cnt == m) && (!recorded[i])) {
                ans.push_back(i + 1);
                recorded[i] = true;
            }
        }
    }
    int sz = ans.size();
    for (int i = 0; i < sz; i++) {
        cout << ans[i];
        if (i < (sz - 1)) cout << " ";
        else cout << endl;
    }
    return 0;
}
```

C++ 示例代码（\( O(K) \) 解法）：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(void){
    int n, m, k;
    int a, b;
    int cnt[10] = {};
    vector<int> ans;
    cin >> n >> m >> k;
    for (int i = 0; i < k; i++) {
        cin >> a >> b;
        cnt[a-1]++;
        if (cnt[a-1] == m) ans.push_back(a);
    }
    int sz = ans.size();
    for (int i = 0; i < sz; i++) {
        cout << ans[i];
        if (i < (sz - 1)) cout << " ";
        else cout << endl;
    }
    return 0;
}
```

# c

个人

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
vector<ll> c[200010];
bool vis[200010];     
void dfs(ll u) {
    vis[u]=1;
    for(auto v:c[u]) {
        if(!vis[v])dfs(v);
    }
}
void sove(){
    ll n,ans=0;
    cin>>n;
    vector<ll>d(n); 
    for (int i=1;i<=n;i++) {
        ll a,b;
        cin>>a>>b;
        if (a ==0&&b==0) {
           d.push_back(i);
        } else {
            c[a].push_back(i); 
            c[b].push_back(i); 
        }
    }
    for (auto x:d) {
        if(!vis[x])dfs(x);
    }
    ans=count(vis+1,vis+n+1,1);
    cout<<ans<<"\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    ll t=1;
    //cin>>t;
    while(t--)sove();
    return 0;
}
```

标答

考虑一个有向图，其顶点代表技能。对于每个尚未掌握的技能 *i*，从技能 *A**i* 到技能 *i* 画一条有向边，再从技能 *B**i* 到技能 *i* 画一条有向边。在这个图中，一个技能最终可以被掌握，当且仅当它可以从某个初始已掌握的技能到达（即存在一条从初始技能到该技能的有向路径）。

因此，只需通过从初始已掌握的技能开始进行深度优先搜索（DFS）或广度优先搜索（BFS），检查图中每个顶点是否可达，即可解决问题。这种方法的时间复杂度为 *O*(*N*)。

可以定义一个“虚拟技能 0”，并假设只有技能 0 是初始已掌握的。这样，DFS 或 BFS 只需从单个顶点（技能 0）开始即可。

```python
import sys
sys.setrecursionlimit(10**9)
N = int(input())
G = [[] for _ in range(N + 1)]
for i in range(1, N + 1):
    a, b = map(int, input().split())
    G[a].append(i)
    G[b].append(i)
ok = [0] * (N + 1)
ok[0] = 1
def dfs(v):
    ok[v] = 1
    for vv in G[v]:
        if not ok[vv]:
            dfs(vv)
dfs(0)
print(sum(ok) - 1)
```

作者提供的 C++ 解法：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int N;
    cin >> N;
    vector<vector<int>> G(N + 1);
    
    for (int i = 1; i <= N; i++) {
        int a, b;
        cin >> a >> b;
        G[a].push_back(i);
        G[b].push_back(i);
    }
    vector<bool> ok(N + 1);
    ok[0] = true;
    auto dfs = [&](auto self, int v) -> void {
        ok[v] = true;
        for (auto vv : G[v]) if (!ok[vv]) {
            self(self, vv);
        }
    };
    
    dfs(dfs, 0);
    
    int ans = 0;
    for (auto x : ok) ans += x;
    cout << ans - 1 << endl;
}
```



# d

个人

```cpp
 #include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,ans;
char c[10][10];
void dfs(int x,int y,int f) {
    if(f>=ans) return ;
    if(y==m+1) x++,y=1;
    if(x==n+1) ans=f;
    if(c[x][y]=='.') return dfs(x,y+1,f);
    if(x==1||y==1||c[x-1][y]!='#'||c[x][y-1]!='#'||c[x-1][y-1]!='#') dfs(x,y+1,f);
    c[x][y]='.';
    dfs(x,y+1,f+1);
    c[x][y]='#';
}
void sove(){
  cin >> n >> m;
  ans=n*m;
        for(int i = 1;i <= n;i ++) for(int j = 1;j <= m;j ++) cin >> c[i][j];
        dfs(1,1,0);
        cout << ans << "\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    ll t;
    cin>>t;
    while(t--)sove();
    return 0;
}
标答
    
```

这个问题可以通过多种方法解决。以下是几种解决方案：

1. **使用按行扫描的位动态规划（Bit DP）**：从顶部行到底部行扫描网格，同时管理上一行单元格的状态。
2. **使用按单元格索引字典序扫描的位动态规划**：按照单元格索引 (*i*,*j*) 的字典序扫描网格，同时维护最后 *W*+1 个单元格的状态。
3. **利用问题答案最多为 9 的性质进行带剪枝的暴力搜索**：如果对于所有满足 1≤*i*≤*H* 且 1≤*j*≤*W* 的偶数对 (*i*,*j*)，单元格 (*i*,*j*) 都被涂成白色，则无论其他单元格的状态如何，条件都能满足。在问题的约束条件 *H*,*W*≤7 下，这样的单元格不超过 9 个，且需要重新涂色以达到这种状态的单元格数量也不超过 9 个。因此，存在一种方法可以通过重新涂色不超过 9 个单元格来满足条件，即需要重新涂色的单元格的最小数量最多为 9。

这里我们仅介绍第一种解决方案。

定义第 *i* 行（1≤*i*≤*H*）的状态为 *x**i*,1+2⋅*x**i*,2+22⋅*x**i*,3+⋯+2*W*−1⋅*x**i*,*W*，其中 *x**i*,*j*（1≤*j*≤*W*）在单元格 (*i*,*j*) 为白色时为 0，为黑色时为 1。那么，任何行的状态都可以用一个介于 0 和 2*W*−1 之间的整数表示。

接下来，定义 *d**p*[*i*][*j*]（1≤*i*≤*N*，0≤*j*≤2*W*−1）为满足以下两个条件时，将前 *i* 行重新涂色为白色所需的最小黑单元格数量（如果无法满足条件，则为 +∞）：

1. 重新涂色后的网格的前 *i* 行不包含 2×2 的全黑正方形区域。
2. 第 *i* 行的状态为 *j*。

首先考虑 *d**p*[1][*j*]。由于第二个条件自动满足，只需考虑第一个条件。如果状态 *j* 可以通过将第 1 行的初始状态中的一些黑单元格重新涂色为白色得到，则 *d**p*[1][*j*] 为需要重新涂色的单元格数量；否则，为 +∞。

接下来，假设我们已经找到了所有 0≤*j*′<2*W* 的 *d**p*[*i*][*j*′]，现在想要找到 *d**p*[*i*+1][*j*]。首先，如果状态 *j* 不能通过将第 (*i*+1) 行的初始状态中的一些黑单元格重新涂色为白色得到，则 *d**p*[*i*+1][*j*] 为 +∞。否则，设 *S* 为第 *i* 行的状态 *j*′ 的集合，使得当第 *i* 行的状态为 *j*′ 且第 (*i*+1) 行的状态为 *j* 时，这两行不包含 2×2 的全黑区域。那么我们有 *d**p*[*i*+1][*j*]=min*j*′∈*S**d**p*[*i*][*j*′]+*x*，其中 *x* 是将第 (*i*+1) 行的状态变为 *j* 所需重新涂色的单元格数量。

根据 *d**p*[*i*][*j*′] 和 *S* 的定义，注意可以通过恰好进行 *d**p*[*i*][*j*′]+*x* 次操作，使得前 (*i*+1) 行不包含 2×2 的全黑区域，并且第 *i* 行和第 (*i*+1) 行的状态分别为 *j*′ 和 *j*。同时，注意这是完成此操作所需的最小操作次数。通过对第 *i* 行的所有可能状态取最小值，可以找到满足 *d**p*[*i*+1][*j*] 定义的值。

答案为 min0≤*j*<2*W**d**p*[*N*][*j*]。

复杂度分析：由于 *d**p* 数组有 *H*⋅2*W* 个元素，且更新一个元素需要取最多 2*W* 个值的最小值，因此每个测试用例的时间复杂度为 *O*(*H*⋅4*W*)。因此，总时间复杂度为 *O*(*T**H*⋅4*W*)；由于 *T**H*⋅4*W*≤100⋅7⋅214∼107，这在问题的约束条件下足够快。
因此，问题已解决。

第二种解决方案允许我们以更快的 *O*(*T**H**W*⋅2*W*) 时间解决问题

以下是 C++ 的示例代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define INF (int)1e+9
#define rep(i, n) for(int i = 0; i < n; ++i)
int main(void){
    int t;
    cin>>t;
    rep(_,t){
        int h,w,k;
        cin>>h>>w;
        k=1<<w;
        vector<string>s(h);
        rep(i,h)cin>>s[i];
        vector<vector<bool> >allow(k,vector<bool>(k,true));
        rep(i,k){
            rep(j,k){
                rep(ii,w-1){
                    if((((i>>ii)&3)==3)&&(((j>>ii)&3)==3)){
                        allow[i][j]=false;
                        break;
                    }
                }
            }
        }
        vector<int>dp(k,INF);
        dp[0]=0;
        rep(i,h){
            int state=0;
            rep(j,w)if(s[i][j]=='#')state+=(1<<j);
            vector<int>dp2(k,INF);
            rep(j,k){
                if((j|state)==state){
                    rep(jj,k){
                        if(allow[jj][j])dp2[j]=min(dp2[j],dp[jj]+std::popcount(((unsigned int)(j^state))));
                    }
                }
            }
            dp=dp2;
        }
        int ans=INF;
        rep(i,k)ans=min(ans,dp[i]);
        cout<<ans<<endl;
    }
    
    return 0;
}
```

# e

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
ll t, n, k, x;
priority_queue< pair<double, ll> > pq;
void sove(){
        cin >> n >> k >> x;
        while( !pq.empty() ) pq.pop();
        for( int i=0 ; i<n ; i++ ){
            double a;
            cin >> a;
            pq.push({ a, 1 });
        }
        while( 1 ){
            auto [a, c]=pq.top();
            pq.pop();
            if( k<=c ){
                pq.push({ a/2.0, k*2 });
                pq.push({ a, c-k });
                break;
            }
            else{
                k-=c;
                pq.push({ a/2.0, c*2 });
            }
        }
        while( x>0 ){
            auto [a, c]=pq.top();
            pq.pop();
            x-=c;
            if( x<=0 ){
                printf( "%.20f\n", a );
                break;
            }
        }
    }
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
    ll t;
    cin>>t;
    while(t--)sove();
    
    return 0;
}
标答
   该问题可以通过对答案执行二分查找来解决。

首先，考虑以下问题：

问题1：一个袋子里有一根长度为$A$的木棍。需要进行多少次操作才能使所有木棍的长度都为$D$或更短？

由于木棍的长度始终为$\frac{A}{2^k}$的形式，因此该问题的答案是$2^k - 1$，其中$k$是满足$\frac{A}{2^k} \leq D$的最小整数。

问题2：一个袋子里有$N$根长度分别为$A_1, \ldots, A_N$的木棍。需要进行多少次操作才能使所有木棍的长度都为$D$或更短？

这可以通过对每根木棍独立求解问题1来得出答案。

问题3：一个袋子里有$N$根长度分别为$A_1, \ldots, A_N$的木棍。进行$K$次操作后，最长的木棍有多长？

这可以通过使用二分查找将问题归结为问题2来解决。

问题4：一个袋子里有$N$根长度分别为$A_1, \ldots, A_N$的木棍。进行$K$次操作后，第$X$长的木棍有多长？

我们首先解决问题3，以确定每根木棍操作后的长度。由于操作后最多可能有$(N + 1)$种不同的长度，因此可以通过统计每种长度的木棍数量来找到答案。

在此过程中出现的所有数字都可以精确表示为64位浮点数，而不会产生误差。
```

# f

[Editorial - AtCoder Beginner Contest 424](https://atcoder.jp/contests/abc424/editorial/13940)

# g

[Editori
